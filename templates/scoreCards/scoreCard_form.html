<!--
    Liste des fonctions
        - hasRunnersOnBase : Vérifie si il y as un coureur sur base
-->

{% extends "menu.html" %}

{% block title %}Saisie Play-by-Play FFBS{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/global.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/plays.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/plays/menuRadial.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/plays/playByPlay.css') }}">
{% endblock %}

{% block content %}

<div class="scorecard-container">
    <h2>⚾ Saisie DU MATCH  - {{ away_team.name }} vs {{ home_team.name }}</h2>

    <div class="main-content-layout">
        
        <div class="left-column">
            <!-- Panneau de contrôle du match -->
            <div class="game-control-panel">
                <div style="display: flex; justify-content: space-around; align-items: flex-start; margin-bottom: 20px;">
                    <div class="control-info-group">
                        <div class="control-group">
                            <h4>Manche Actuelle</h4>
                            <div class="flex">
                                <span id="currentInningDisplay" class="bold vertical-center"></span>
                                <button id="nextInningBtn">▶️ Fin de Manche</button>
                            </div>
                        </div>
                        <div class="control-group teamPositionDisplay">
                            <div class="control-group" style="margin-top: 15px;">
                                <h4>Équipe au Bâton</h4>
                                <span id="currentBattingTeam"></span>
                            </div>
                            <div class="control-group" style="margin-top: 15px;">
                                <h4>Équipe en Défense</h4>
                                <span id="currentDefendingTeam"></span> 
                            </div>
                        </div>
                        <div class="control-group" style="margin-top: 15px;">
                            <h4>Outs</h4>

                            <div class="out1 circle circle-empty"></div>
                            <div class="out1 circle circle-red"></div>
                            <div class="out2 circle circle-empty"></div>
                            <div class="out2 circle circle-red"></div>
                            <div class="out3 circle circle-empty"></div>
                            <div class="out3 circle circle-red"></div>
                        </div>
                    </div>
                    <!-- Schema terrain de baseball -->
                    <div class="field-diagram-container" id="fieldDiagramContainer">
                        <div class="diamond-area"></div>
                        
                        <div id="pitcher-mound"></div>

                        <div class="foul-line" id="foul-line-left"></div>
                        <div class="foul-line" id="foul-line-right"></div>
                        
                        <div class="defensive-player" id="player-P"></div>
                        <div class="defensive-player" id="player-C"></div>
                        <div class="defensive-player" id="player-1B"></div>
                        <div class="defensive-player" id="player-2B"></div>
                        <div class="defensive-player" id="player-3B"></div>
                        <div class="defensive-player" id="player-SS"></div>
                        <div class="defensive-player" id="player-LF"></div>
                        <div class="defensive-player" id="player-CF"></div>
                        <div class="defensive-player" id="player-RF"></div>

                        <div class="diamond">
                            <div class="base" id="base-3-visuel">
                                <span class="runner-name" id="runner-3B"></span>
                            </div>
                            <div class="base" id="base-2-visuel">
                                <span class="runner-name" id="runner-2B"></span>
                            </div>
                            <div class="base" id="base-1-visuel">
                                <span class="runner-name" id="runner-1B"></span>
                            </div>
                            <div id="home-plate"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bas : Inscrire l'action suivante -->
            <div class="action-input-section">
                <h3>Nouvelle Action au Bâton</h3>
                <label for="batterSelect">Batteur Actuel :</label>
                <select id="batterSelect">
                    </select>
                
                <button id="selectActionBtn" style="padding: 10px 15px; background-color: green; color: white; border: none; cursor: pointer;">
                    Sélectionner l'Action
                </button>
            </div>
        </div>
        <!-- Colonne de droite : Play By Play -->
        <div class="right-column">
            <h3>Play by Play</h3>
            <div class="log-section" id="playByPlayLog">

            </div>
        </div>
        </div>
    </div>

<!-- Menu radial -->
<div class="radial-menu" id="radialMenu">
    <button class="close-menu-btn" id="closeMenuBtn">X</button>
</div>


<!-- Fenêtre d'ajout d'une action -->
<div id="actionDetailModal" class="modal">
    <div class="modal-content">
        <h3>Détails de l'Action: <strong id="modalActionCode"></strong></h3>
        
        <p>Batteur: <strong id="modalBatterName"></strong></p>
        <hr>

        <h4>État Initial des Bases (Simulé)</h4>
        <div class="base-state-selector" id="baseStateSelector">
            </div>
        <hr>

        <h4>Mouvements des Coureurs et Outs</h4>
        <div id="runnerActionsContainer">
            </div>
        <hr>

        <label for="defensiveCodeModal">Code Défensif / Erreur / Zone de frappe (Ex: 6-4-3, E6) :</label>
        <input type="text" id="defensiveCodeModal" placeholder="Code défensif ou Erreur (Obligatoire)" style="width: 100%; padding: 8px; margin-bottom: 10px;">
        
        <label for="outsGenerated">Outs générés par l'action :</label>
        <select id="outsGenerated" style="padding: 5px; margin-bottom: 20px;">
            <option value="0">0 Out</option>
            <option value="1">1 Out</option>
            <option value="2">2 Outs</option>
            <option value="3">3 Outs</option>
        </select>
        
        <button id="submitActionDetailBtn" style="background-color: green; color: white; padding: 10px 15px; border: none; cursor: pointer;">
            Enregistrer l'Action
        </button>
        <button id="cancelActionDetailBtn" style="background-color: #ccc; color: black; padding: 10px 15px; border: none; cursor: pointer; margin-left: 10px;">
            Annuler
        </button>
    </div>
</div>

<!-- Ce que l'on doit laisser dans le script -->
<script>
    // Variables de match (transférées depuis Jinja)
    const HOME_TEAM_ID = {{ home_team.id }};
    const AWAY_TEAM_ID = {{ away_team.id }};
    const MATCH_ID = {{ match.id }};
    const homeRoster = {{ home_roster | tojson }};
    const awayRoster = {{ away_roster | tojson }};
    // Re-ajout de la variable pour charger l'historique
    const matchPlays = {{ match_plays | tojson }};

    const batterSelect = document.getElementById('batterSelect');
    batterSelect.value = 3;
</script>    

<!-- On charge les JS après définition des constantes -->
<script src="{{ url_for('static', filename='js/scoreCard.js') }}"></script>
<script src="{{ url_for('static', filename='js/menuRadial.js') }}"></script>
<script src="{{ url_for('static', filename='js/playByPlay.js') }}"></script>
<script src="{{ url_for('static', filename='js/batterSelect.js') }}"></script>
<script src="{{ url_for('static', filename='js/gameControl.js') }}"></script>
<script src="{{ url_for('static', filename='js/globalPlay.js') }}"></script>
<script src="{{ url_for('static', filename='js/schemaField.js') }}"></script>
<script src="{{ url_for('static', filename='js/modaleAction.js') }}"></script>

<script>
    // État du jeu
    let currentInning = 1;
    let isTopInning = true; 
    let currentOuts = 0;
    let currentBattingTeamRoster = awayRoster; 
    let baseState = { // { Base: RosterOrder du joueur, ou null }
        '1B': null,
        '2B': null,
        '3B': null
    };
    // Données de l'action en cours de saisie
    let pendingActionData = {};

    // ------------------------------------------------------------------
    // ÉLÉMENTS DU DOM & UTILITAIRES
    // ------------------------------------------------------------------
    const closeMenuBtn = document.getElementById('closeMenuBtn');
    const actionDetailModal = document.getElementById('actionDetailModal');
    const selectActionBtn = document.getElementById('selectActionBtn');
    const currentInningDisplay = document.getElementById('currentInningDisplay');
    const outsDisplay = document.getElementById('outsDisplay');
    const nextInningBtn = document.getElementById('nextInningBtn');
    const rosterMap = {}; 

    // --- LOGIQUE D'AVANCEMENT ET DE CHARGEMENT DE L'HISTORIQUE (RE-AJOUTÉ) ---

    /**
     * Logique interne d'avancement du batteur et des manches, sans mise à jour du DOM.
     * @param {number} newOuts - Nombre d'outs générés par l'action.
     * @param {boolean} isLoading - Vrai si appelé depuis loadMatchHistory.
     */
    function internalAdvanceGame(newOuts = 0, isLoading = false) {
        currentOuts += newOuts;

        const currentRosterOrder = parseInt(batterSelect.value, 10);
        let nextRosterOrder = currentRosterOrder + 1;
        
        const activeRoster = currentBattingTeamRoster.filter(entry => entry.roster_order !== 0 && entry.roster_order !== null);
        const maxOrder = activeRoster.reduce((max, entry) => Math.max(max, entry.roster_order), 0);
        
        if (currentOuts < 3) {
            if (nextRosterOrder > maxOrder) {
                nextRosterOrder = 1;
            }
            // FIX: Assurer que la valeur est une chaîne pour le sélecteur
            //batterSelect.value = String(nextRosterOrder);
            
        } else {
            // Changement de demi-manche
            currentOuts = 0;
            if (!isLoading) {
                baseState = { '1B': null, '2B': null, '3B': null }; 
            }
            
            if (!isTopInning) {
                currentInning++; 
            }
            isTopInning = !isTopInning; 
            
            // FIX: Assurer que la valeur est une chaîne
            batterSelect.value = '1'; 
        }
        
        currentBattingTeamRoster = isTopInning ? awayRoster : homeRoster;
    }

    /**
     * Avance le jeu après une action ou un changement de demi-manche.
     */
    function advanceGame(newOuts = 0, runsScored = 0) {
        internalAdvanceGame(newOuts, false);
        updateGameDisplay(); 
    }

    closeMenuBtn.addEventListener('click', closeRadialMenu);


    // ------------------------------------------------------------------
    // GESTION DE LA MODALE DE DÉTAILS D'ACTION (Logique conservée pour la clarté)
    // ------------------------------------------------------------------

    function calculateForcedAdvance(startBase, batterActionCode) {
        const baseIndexMap = {'1B': 1, '2B': 2, '3B': 3};
        const baseStart = baseIndexMap[startBase];
        
        if (!baseStart) return 'stay';

        let basesGained = 0;
        
        switch (batterActionCode) {
            case 'BB': 
            case 'HP':
            case '1B':
            case 'E':
                basesGained = 1;
                break;
            case '2B':
                basesGained = 2;
                break;
            case '3B':
                basesGained = 3;
                break;
            case 'HR':
            case 'H':
                basesGained = 4;
                break;
            default:
                return 'stay'; 
        }
        
        // Logique de force avancée
        if (basesGained === 1 && baseState['1B'] !== null && baseState['2B'] === null && baseStart !== 1) {
             // Si c'est seulement un avancement d'une base (BB, HP, 1B), et qu'il y a un trou devant le coureur, il n'est pas forcé
             return 'stay'; 
        }
        
        let forcedEndIndex = baseStart + basesGained;
        
        const baseReverseMap = {1: '1B', 2: '2B', 3: '3B'};
        
        if (forcedEndIndex >= 4) return 'H'; 
        
        // Si la base d'arrivée forcée est la base actuelle, cela signifie 'stay' (pas d'avancement forcé au-delà)
        if (forcedEndIndex === baseStart) return 'stay';
        
        return baseReverseMap[forcedEndIndex] || 'stay'; 
    }
    
    function populateRunnerActions(batterName, batterRosterOrder, actionCode, teamId) {
        const container = document.getElementById('runnerActionsContainer');
        container.innerHTML = '';
        
        const batterDefaultEndBase = getBatterDefaultEndBase(actionCode);
        const isRunnerOnlyAction = ['SB', 'CS', 'WP', 'PB'].includes(actionCode);
        
        // Map des bases pour générer les options et vérifier l'ordre
        const baseIndexMap = { 'BATTER': 0, '1B': 1, '2B': 2, '3B': 3 };


        const createRunnerRow = (baseId, runnerName, runnerRosterOrder, teamId, isBatter) => {
            const row = document.createElement('div');
            row.classList.add('runner-row');
            row.dataset.runnerRosterOrder = runnerRosterOrder;
            row.dataset.startBase = baseId;
            row.dataset.teamId = teamId;
            
            const currentBaseIndex = baseIndexMap[baseId];

            const nameDiv = document.createElement('div');
            nameDiv.classList.add('runner-info');
            nameDiv.textContent = `${baseId === 'BATTER' ? 'BAT' : baseId} : ${runnerName}`;
            
            const select = document.createElement('select');
            select.classList.add('runner-action-select');
            
            let optionsHtml = '';
            
            // 1. Option 'Stay' (Reste sur la base actuelle)
            optionsHtml += `<option value="stay">Reste à ${isBatter ? 'BAT' : baseId}</option>`;
            
            // 2. Options d'avancement (uniquement vers l'avant)
            for (const base of ['1B', '2B', '3B']) {
                const baseIndex = baseIndexMap[base];
                
                // Le batteur peut aller à 1B, 2B, 3B (index > 0)
                // Un coureur sur base ne peut aller qu'aux bases dont l'index est STRICTEMENT supérieur.
                if (isBatter && baseIndex > 0) {
                     optionsHtml += `<option value="${base}">Avance à ${base}</option>`;
                } else if (!isBatter && baseIndex > currentBaseIndex) {
                     optionsHtml += `<option value="${base}">Avance à ${base}</option>`;
                }
            }
            
            // 3. Option 'Home' (Marque)
            optionsHtml += `<option value="H">Marque (Point)</option>`;

            // 4. Option 'Out'
            optionsHtml += `<option value="out">Éliminé (Out)</option>`;
            
            select.innerHTML = optionsHtml;
            
            
            // --- Logique de sélection par défaut (Avancement forcé ou action coureur) ---
            let defaultEndBase = 'stay';

            if (isBatter) {
                 defaultEndBase = batterDefaultEndBase; // Ex: '1B', '2B', 'out'
            } else if (isRunnerOnlyAction) {
                // Logique spécifique aux actions de coureurs
                if (actionCode === 'SB') {
                    if (baseId === '1B') defaultEndBase = '2B';
                    else if (baseId === '2B') defaultEndBase = '3B';
                    else if (baseId === '3B') defaultEndBase = 'H';
                } else if (actionCode === 'CS') {
                    defaultEndBase = 'out';
                } else if (actionCode === 'WP' || actionCode === 'PB') {
                    // Les coureurs avancent d'une base par défaut, s'ils ne sont pas forcés
                    if (baseId === '1B' || baseId === '2B') defaultEndBase = baseIndexMap[baseId] === 1 ? '2B' : '3B';
                    else if (baseId === '3B') defaultEndBase = 'H';
                }
            } else {
                 // Logique d'avancement forcé pour les coureurs sur base
                 defaultEndBase = calculateForcedAdvance(baseId, actionCode);
            }
            
            // Application de la valeur par défaut
            if (defaultEndBase === 'out') {
                select.value = 'out';
            } else if (defaultEndBase === 'H') {
                select.value = 'H';
            } else if (['1B', '2B', '3B'].includes(defaultEndBase)) {
                 select.value = defaultEndBase;
            } else { 
                 // Si c'est 'stay', 'stay' est la valeur par défaut
                 select.value = 'stay';
            }


            row.appendChild(nameDiv);
            row.appendChild(select);
            container.appendChild(row);
        };
        
        if (!isRunnerOnlyAction) {
            createRunnerRow('BATTER', batterName, batterRosterOrder, teamId, true);
        } else {
            const infoDiv = document.createElement('div');
            infoDiv.innerHTML = `<strong>(Action de coureur : Pas d'action au bâton)</strong>`;
            container.appendChild(infoDiv);
        }
        
        Object.keys(baseState).forEach(baseId => {
            const runnerRosterOrder = baseState[baseId];
            if (runnerRosterOrder) {
                const runnerName = getRunnerName(runnerRosterOrder, teamId);
                createRunnerRow(baseId, runnerName, runnerRosterOrder, teamId, false);
            }
        });
        
        updateBaseStateSelector();
    }
    
    function updateBaseStateSelector() {
        const selector = document.getElementById('baseStateSelector');
        selector.innerHTML = '';
        
        const baseLabels = { '1B': '1ère', '2B': '2ème', '3B': '3ème' };
        const teamId = isTopInning ? AWAY_TEAM_ID : HOME_TEAM_ID;
        
        ['3B', '2B', '1B'].forEach(baseId => { // Affichage de la 3B à la 1B
            const runnerRosterOrder = baseState[baseId];
            const item = document.createElement('div');
            item.classList.add('base-state-item');
            
            let runnerName = 'VIDE';
            if (runnerRosterOrder) {
                runnerName = getRunnerName(runnerRosterOrder, teamId).split(' ').pop(); 
                item.classList.add('occupied');
            }
            
            item.innerHTML = `
                <div class="base-icon">${baseId}</div>
                <div>${baseLabels[baseId]}</div>
                <div class="base-runner-name">${runnerName}</div>
            `;
            selector.appendChild(item);
        });
    }

    async function submitActionDetail() {
        const defensiveCode = document.getElementById('defensiveCodeModal').value.trim();
        
        if (defensiveCode === '') {
            alert("Le champ 'Code Défensif / Erreur / Zone de frappe' est obligatoire pour enregistrer l'action.");
            return; 
        }
        
        const outsGenerated = parseInt(document.getElementById('outsGenerated').value, 10);
        const runnerRows = document.querySelectorAll('#runnerActionsContainer .runner-row');
        
        let newBaseState = { '1B': null, '2B': null, '3B': null };
        let totalRuns = 0;
        let movements = [];
        
        // 1. Déterminer les mouvements et l'état final des bases
        runnerRows.forEach(row => {
            const startBase = row.dataset.startBase; 
            const runnerRosterOrder = row.dataset.runnerRosterOrder; 
            const endAction = row.querySelector('.runner-action-select').value;
            const isBatter = (startBase === 'BATTER');
            
            let endBase = endAction;
            let isOut = false;
            let scored = false;

            if (endAction === 'out') {
                endBase = 'Out';
                isOut = true;
            } else if (endAction === 'H') {
                endBase = 'H';
                scored = true;
            } else if (endAction === 'stay') {
                 // 'stay' signifie que le coureur reste sur sa base de départ
                 endBase = startBase;
            }
            // Si endAction est '1B', '2B', ou '3B', endBase est déjà endAction
            

            if (['1B', '2B', '3B'].includes(endBase) && !isOut) {
                newBaseState[endBase] = runnerRosterOrder;
            }
            if (scored) {
                totalRuns++;
            }

            movements.push({
                player_roster_order: parseInt(runnerRosterOrder, 10), 
                start: isBatter ? 'H' : startBase,
                end: endBase,
                scored: scored,
                out: isOut
            });
        });
        
        // 2. Finalisation des données à envoyer
        pendingActionData.defensiveCode = defensiveCode;
        pendingActionData.outsGenerated = outsGenerated; 
        pendingActionData.runsScored = totalRuns;
        pendingActionData.movements = movements;
        
        try {
             // **NOTE IMPORTANTE :** L'appel API est laissé commenté si non fonctionnel
            /*
            const response = await fetch(`/match/${MATCH_ID}/scoreCards`, { 
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(pendingActionData)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Erreur lors de l'enregistrement du jeu (Code: ${response.status}).`);
            }
            const data = await response.json();
            */
            
            // Simulation de succès
            const data = pendingActionData;

            // Mise à jour de l'état global du jeu UNIQUEMENT après succès (simulé)
            baseState = newBaseState; 
            
            logAction(data);
            
            advanceGame(outsGenerated, totalRuns);
            
            actionDetailModal.style.display = 'none';

        } catch (error) {
            console.error('Erreur API:', error);
            alert(`Échec de l'enregistrement de l'action : ${error.message}`);
        }
    }
    
    // ------------------------------------------------------------------
    // INITIALISATION ET ÉCOUTEURS
    // ------------------------------------------------------------------
    document.addEventListener('DOMContentLoaded', function() {
        
        buildRosterMap(homeRoster);
        buildRosterMap(awayRoster);
        
        // 1. Charger et reconstruire l'état à partir de l'historique
        if (typeof matchPlays !== 'undefined' && matchPlays && matchPlays.length > 0) {
            loadMatchHistory(matchPlays); 
        }
        
        // 2. Mettre à jour l'affichage avec l'état final reconstruit
        updateGameDisplay();
        
        document.getElementById('submitActionDetailBtn').addEventListener('click', submitActionDetail);
        document.getElementById('cancelActionDetailBtn').addEventListener('click', () => {
             actionDetailModal.style.display = 'none';
        });
        
        selectActionBtn.addEventListener('click', openRadialMenu);
        nextInningBtn.addEventListener('click', () => {
            // Force le changement de demi-manche (3 outs)
            advanceGame(3 - currentOuts); 
        });
        
    });
</script>

{% endblock %}